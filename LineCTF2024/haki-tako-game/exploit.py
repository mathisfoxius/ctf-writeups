import pwn
import json

host = "localhost"
port = 11223

conn = pwn.remote(host, port)
initial_data = conn.recv()

data_str = initial_data.decode()
data_dict = json.loads(data_str)

gcm_nonce = data_dict["nonce"]
gcm_ciphertext = data_dict["ct"]
gcm_ctr = ""
for ctr in range(2, 24):
    gcm_ctr += f"{gcm_nonce}{hex(ctr)[2:]:0>8}"

cfb_ciphertext = gcm_ctr

# CFB
conn.sendline(cfb_ciphertext.encode())
res = conn.recvline()

data_str = res.decode()
data_dict = json.loads(data_str)

cfb_truncated_pt = data_dict["ret"]

enc_dict = {}
for i in range(21):
    encryption_plaintext = cfb_ciphertext[32 * i:32 * (i + 1)]
    next_ct = int(cfb_ciphertext[32 * (i + 1):32 * (i + 2)], 16)
    this_pt = int(cfb_truncated_pt[32 * (i + 1):32 * (i + 2)], 16)
    encryption_ciphertext = f"{hex(next_ct ^ this_pt)[2:]:0>32}"
    enc_dict[encryption_plaintext] = encryption_ciphertext

# CBC Phase
nb_found = 0
debug = False
for current_encryption_plaintext in enc_dict.keys():
    print(f"Bruteforcing for block {nb_found}")
    found_variation = False
    v = 0x0000
    # make 31 blocks with variations of encryption_ciphertext with xor 0000 through ffff
    base = enc_dict[current_encryption_plaintext]
    while not found_variation:
        variations_ciphertext = ""
        for _ in range(31):
            v += 1
            variations_ciphertext += f"{base[:28]}{hex(v)[2:]:0>4}"

        conn.sendline(variations_ciphertext.encode())
        cbc_answer = conn.recvline()

        data_str = cbc_answer.decode()
        data_dict = json.loads(data_str)

        cbc_ret = data_dict["ret"]

        for i in range(31):
            if i == 0:  # take IV
                prev_ct = int("5f885849eadbc8c7bce244f8548a443f", 16)
            else:
                prev_ct = int(variations_ciphertext[32 * (i - 1):32 * i], 16)

            cbc_plaintext = int(cbc_ret[32 * i:32 * (i + 1)], 16)
            cbc_aes_output = f"{hex(prev_ct ^ cbc_plaintext)[2:]:0>32}"

            if cbc_aes_output == current_encryption_plaintext:
                nb_found += 1
                found_variation = True
                enc_dict[current_encryption_plaintext] = variations_ciphertext[32 * i:32 * (i + 1)]


# back to GCM
result_hex = ""
for block_i in range(21):
    gcm_aes_output_int = int(enc_dict[gcm_ctr[32 * block_i:32 * (block_i + 1)]], 16)
    gcm_ciphertext_int = int(gcm_ciphertext[32 * block_i:32 * (block_i + 1)], 16)
    result_hex += f"{hex(gcm_aes_output_int ^ gcm_ciphertext_int)[2:]:0>32}"


result_bytes = bytes.fromhex(result_hex)
print(result_bytes)

extracted_pin = result_bytes[29:285].hex()

conn.sendline(extracted_pin.encode())
cbc_answer = conn.recvline()

data_str = cbc_answer.decode()
data_dict = json.loads(data_str)

print(data_dict)

conn.close()
